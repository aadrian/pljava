<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2020-10-04 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PostgreSQL PL/Java &#x2013; Migrating base-UDT data byte order without a dump/reload</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20201004" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean">
                                                <img src="../images/pljava_logo.jpg" alt="PL/Java logo combining the PostgreSQL elephant and a Java bean" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2020-10-04</span>
                  &nbsp;| <span id="projectVersion">Version: 1.5.6</span>
                      </div>
            <div class="xright">                    <a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a>
            |
                        <a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a>
            |
                        <a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a>
            |
                        <a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Usage</h5>
                  <ul>
                  <li class="none">
                          <a href="../build/build.html" title="Building PL/Java">Building PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a>
            </li>
                  <li class="none">
                          <a href="../install/upgrade.html" title="Upgrading">Upgrading</a>
            </li>
                  <li class="none">
                          <a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../use/use.html" title="User guide">User guide</a>
            </li>
                  <li class="none">
                          <a href="../develop/develop.html" title="Developer notes">Developer notes</a>
            </li>
          </ul>
                       <h5>Release Information</h5>
                  <ul>
                  <li class="none">
                          <a href="../releasenotes.html" title="Release notes">Release notes</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a>
            </li>
                  <li class="none">
                          <a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-deploy/index.html" title="PL/Java Deploy">PL/Java Deploy</a>
            </li>
                  <li class="none">
                          <a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a>
            </li>
                  <li class="none">
                          <a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a>
            </li>
                  <li class="none">
                          <a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <h1>Migrating base-UDT data byte order without a dump/reload</h1>
<p>Suppose a database has used PL/Java-defined base types in the past, has data stored in columns of those types, and an upgrade is planned to a future PL/Java release with a changed default byte order for base types. For example, consider this table with a column of type <tt>javatest.complex</tt> (this type is <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/ComplexScalar.java">one of the supplied examples</a>).</p>

<div class="source">
<div class="source">
<pre>postgres=# \d complexcircle
     Table &quot;public.complexcircle&quot;
 Column |       Type       | Modifiers
--------+------------------+-----------
 k      | integer          |
 z      | javatest.complex |

postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</pre></div></div>
<p>The table holds eight equally spaced points around a circle in the complex plane.</p>
<p>Older versions of PL/Java always stored such data with big-endian byte order. PL/Java 1.5.0 allows byte order to be configured, <i>but the default for PL/Java-defined base types remains big-endian</i>. In a future release, the default will be changed to <tt>native</tt>, that is, whatever byte order the underlying hardware uses. Intel-based hardware, for example, is little-endian, and such a change would cause the stored data to be read incorrectly.</p>
<p>In PL/Java 1.5.0, by default, the legacy table will still be handled correctly. The control of byte order is by four Java system properties named <tt>org.postgresql.pljava.udt.byteorder.$kind.$dir</tt> where <tt>$kind</tt> is <tt>scalar</tt> or <tt>mirror</tt> and <tt>$dir</tt> is the conversion direction, <tt>p2j</tt> for data conversions from PostgreSQL to Java or <tt>j2p</tt> for the reverse. Loading a PL/Java 1.5.0 without changing the default settings, a quick query of these properties will confirm what they are:</p>

<div class="source">
<div class="source">
<pre>postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | big_endian
 scalar | j2p | big_endian
(4 rows)
</pre></div></div>
<p>Because scalar (base) types are still using the old, big-endian layout, a <tt>SELECT</tt> from the legacy table should succeed, and it does:</p>

<div class="source">
<div class="source">
<pre>postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</pre></div></div>
<p>But what happens after using <tt>\c</tt> to get a new session, and <tt>SET
pljava.vmoptions</tt> to change the byte order?</p>

<div class="source">
<div class="source">
<pre>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar=native';
SET
postgres=#
</pre></div></div>
<p>Here you can see that a shortcut is possible, to set both the <tt>p2j</tt> and <tt>j2p</tt> properties by leaving the direction off. It is even possible to leave off the kind and direction, and set both conversion directions for both <tt>scalar</tt> and <tt>mirror</tt> types, by setting only one property, <tt>org.postgresql.pljava.udt.byteorder</tt>. <i>This works only at initialization time; after the Java VM is running, these shorter-named properties do not exist, and setting them has no effect.</i></p>
<p>After setting <tt>pljava.vmoptions</tt> as above, querying the properties again should show them set accordingly, and then another query shows how that legacy table looks:</p>

<div class="source">
<div class="source">
<pre>postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | native
 scalar | j2p | native
(4 rows)
postgres=# SELECT * FROM complexcircle;
 k |                         z
---+---------------------------------------------------
 0 | (3.03865E-319,0.0)
 1 | (3.526206619982328E171,2.2885481907327986E191)
 2 | (-1.0377513410652091E170,-1.0377513410652091E170)
 3 | (2.2885481907327986E191,3.526206619982328E171)
 4 | (0.0,3.03865E-319)
 5 | (2.288548190732839E191,3.526206619982328E171)
 6 | (-1.0377513410652263E170,-1.0377513410652091E170)
 7 | (3.526206619982383E171,2.2885481907327986E191)
(8 rows)
</pre></div></div>
<p>Now the table seems to have totally bogus values in the <tt>z</tt> column. <i>Note: as base types go, <tt>javatest.complex</tt> is quite simple, and reading it with the wrong byte order simply produces bogus values. For other Java-defined base types, other symptoms could result, such as exceptions during a query.</i></p>
<div class="section">
<h2><a name="Migrating_legacy_data_with_a_dumpreload"></a>Migrating legacy data with a dump/reload</h2>
<p>An obvious way to migrate the old data would be to do a (non-binary) dump, in a session where the byte-order is still the old default of <tt>big_endian</tt>, then start a new session with the order set to <tt>native</tt>, and reload the data.</p></div>
<div class="section">
<h2><a name="Migrating_data_with_an_UPDATE"></a>Migrating data with an <tt>UPDATE</tt></h2>
<p>In many cases a simpler option is available, exploiting the fact that the two directions <tt>p2j</tt> and <tt>j2p</tt> can have their byte-order set <i>independently</i>.</p>
<p>You should be thinking that, for most purposes, that would be an outlandish thing to do. It can cause even the simplest queries to misbehave:</p>

<div class="source">
<div class="source">
<pre>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar.j2p=native';
SET
postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | big_endian
 scalar | j2p | native
(4 rows)
postgres=# select '(1,2)'::javatest.complex;
         complex
--------------------------
 (3.03865E-319,3.16E-322)
</pre></div></div>
<p>Clearly not the kind of behavior you would want under any normal conditions. <i>And again, note that for other base types, such a query might not just produce weird values, but throw errors or otherwise behave erratically.</i></p>
<p>And yet, for the <i>one special purpose</i> this page is about, having <tt>p2j</tt> and <tt>j2p</tt> set differently is exactly the trick. Let&#x2019;s start another clean session:</p>

<div class="source">
<div class="source">
<pre>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar.p2j=big_endian '
   '-Dorg.postgresql.pljava.udt.byteorder.scalar.j2p=native';
SET
postgres=#
</pre></div></div>
<p>A quick select of a value from the column to be updated should show that it is still read correctly:</p>

<div class="source">
<div class="source">
<pre>postgres=# SELECT z FROM complexcircle LIMIT 1;
     z
-----------
 (1.0,0.0)
</pre></div></div>
<p>Good, that is one of the expected, correct values. Now, what will happen with a simple command like:</p>

<div class="source">
<div class="source">
<pre>postgres=# UPDATE complexcircle SET z = z; -- PostgreSQL is too smart!
UPDATE 8
postgres=# SELECT z FROM complexcircle LIMIT 1;
     z
-----------
 (1.0,0.0)
</pre></div></div>
<p>No joy: the values still look <i>good</i> after this conversion attempt, which is of course <i>not good</i>, because it means nothing useful happened. PostgreSQL looked at <tt>SET z = z</tt> and realized it didn&#x2019;t require doing anything.</p>
<p>What&#x2019;s needed here is a Java function that will take <i>any object</i> as a parameter and return the same object. A function, in other words, that really changes nothing, but PostgreSQL doesn&#x2019;t know that, and will therefore have to convert each stored value to a Java object (<tt>p2j</tt>), convert the returned object back (<tt>j2p</tt>), and store the updated value.</p>
<p>It turns out that exactly such a function is <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/AnyTest.java">already supplied in the examples</a>:</p>

<div class="source">
<div class="source">
<pre>postgres=# \df javatest.loganyelement
                             List of functions
  Schema  |     Name      | Result data type | Argument data types |  Type
----------+---------------+------------------+---------------------+--------
 javatest | loganyelement | anyelement       | anyelement          | normal
(1 row)

postgres=# UPDATE complexcircle SET z = javatest.loganyelement(z);
UPDATE 8
postgres=# SELECT z FROM complexcircle LIMIT 1;
         z
--------------------
 (3.03865E-319,0.0)
(1 row)
</pre></div></div>
<p>Encouragingly, the value now looks <i>bad</i>, which for this purpose is <i>good</i>. How does it look in another clean session, with all byte order properties set to <tt>native</tt>?</p>

<div class="source">
<div class="source">
<pre>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder=native';
SET
postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | native
 scalar | j2p | native
(4 rows)

postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</pre></div></div>
<p>Mission accomplished. After using that procedure to update all columns of legacy data in PL/Java-defined base types, all that remains is to make sure PL/Java will use the new byte order from that point forward. If the migration is done at the time of upgrading to a PL/Java version that makes the new order default, the job is done; if migrating in advance, a persistently-saved <tt>pljava.vmoptions</tt> (in any of the usual ways, such as <tt>ALTER DATABASE ... SET</tt>, <tt>ALTER SYSTEM</tt>, or editing <tt>postgresql.conf</tt>) will need to include the new byte order setting, which can be taken out after a later upgrade to a PL/Java version that makes the new setting the default.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2003&#x2013;2020
                        <a href="http://tada.se/eng/">Tada AB</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
